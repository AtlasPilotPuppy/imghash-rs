pub struct ImageHash {
    pub matrix: Vec<Vec<bool>>,
}

impl ImageHash {
    /// Flattens the bit matrix that represents the [`ImageHash`] into a single vector.
    pub fn flatten(&self) -> Vec<bool> {
        self.matrix.iter().flatten().copied().collect()
    }

    /// Encodes the bit matrix that represents the [`ImageHash`] into a hexadecimal string.
    /// This implementation is strictly compatible with `imagehash` package for Python.
    pub fn python_safe_encode(&self) -> String {
        let mut result = "".to_string();

        // the Python package essentially pads the entire bit array with 0s
        // until it is cleanly encodable into hexadecimal characters.
        // this part essentially does the same thing.
        let mut flattened = self.flatten();
        if flattened.len() % 4 != 0 {
            let padding = 4 - (flattened.len() % 4);
            for _ in 0..padding {
                flattened.push(false);
                flattened.rotate_right(padding)
            }
        }

        // we convert the bit array one character at a time
        for chunk in flattened.chunks(4) {
            let byte = chunk.iter().fold(0, |acc, &bit| (acc << 1) | bit as u8);
            result += &format!("{:x}", byte);
        }

        result
    }

    /// Decodes a hexadecimal string into a bit matrix that represents the [`ImageHash`].
    /// This implementation is strictly compatible with hashes generated by the `imagehash` package
    /// for Python (read on about the width and height parameter).
    ///
    /// The `width` and `height` parameters are used to specify the dimensions of the matrix that the
    /// hash was originally generated from. This is usually 8 x 8 in the original `imagehash` package.
    /// If you have a hash that was generated with the `imagehash` package, check what you specified for
    /// the `hash_size`-parameter when generating the hash. Use this value for the `width` and `height`.
    ///
    /// This implementation actually deviates slightly from the original imagehash package, because
    /// it allows the decoding of hashes that have been generated on non-square matricies. This is because
    /// the original package actually only allows the generation of hashes on square matricies, however this
    /// crate does allow arbitrary dimensions.
    pub fn python_safe_decode(s: &str, width: usize, height: usize) -> Option<ImageHash> {
        // first we validate that the width and height actually make sense with the given string
        let total_length = width * height;
        let possible_max = s.len() * 4;

        if total_length > possible_max || total_length < possible_max - 4 {
            panic!("The string is too short to fill the matrix");
        }

        // the python package essentially pads the entire bit array with 0s to make
        // it encodable. Here we calculate how many bits were padded, which we can then skip
        // in the beginning.
        let mut skip = 0;
        if total_length % 4 != 0 {
            skip = 4 - ((width * height) % 4);
        }

        // we create a matrix of the correct size
        let mut matrix: Vec<Vec<bool>> = vec![vec![false; width]; height];

        let mut row = 0;
        let mut col = 0;
        for (i, b) in s.chars().enumerate() {
            // TODO: unwrap is not safe here
            let digit = b.to_ascii_lowercase().to_digit(16).unwrap();

            // we add the necessary skip that we calculated earlier
            // for the first character
            let mut start = 0;
            if i == 0 {
                start += skip;
            }

            // goes through each of the 4 bits that makes up our hexadecimal character
            for i in start..4 {
                // we extract the bit from the digit
                let bit = (digit >> (3 - i)) & 1;
                matrix[row][col] = bit == 1;

                // increment the column and row if needed
                col += 1;
                if col == width {
                    col = 0;
                    row += 1;
                }
            }
        }

        Some(ImageHash { matrix })
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_image_hash_to_string_without_padding() {
        // Arrange
        // -> resulting bit str: 00100100 11110000
        // -> resulting hex str: 24F0
        let hash = ImageHash {
            matrix: vec![
                vec![false, false, true, false],
                vec![false, true, false, false],
                vec![true, true, true, true],
                vec![false, false, false, false],
            ],
        };

        // Assert
        assert_eq!(hash.python_safe_encode(), "24f0");
    }

    #[test]
    fn test_image_hash_to_string_with_padding() {
        // Arrange
        // -> resulting bit str: 01101010 00111110 0001
        // -> resulting hex str: 6A3E1
        let hash = ImageHash {
            matrix: vec![
                vec![false, true, true, false, true],
                vec![false, true, false, false, false],
                vec![true, true, true, true, true],
                vec![false, false, false, false, true],
            ],
        };

        // Assert
        assert_eq!(hash.python_safe_encode(), "6a3e1");
    }

    #[test]
    fn test_image_hash_to_string_with_uneven() {
        // Arrange
        // -> resulting bit str: 0110 1010 0001 1111
        // -> resulting hex str: 6A1F
        let hash = ImageHash {
            matrix: vec![
                vec![false, true, true, false, true],
                vec![false, true, false, false, false],
                vec![true, true, true, true, true],
            ],
        };

        // Assert
        assert_eq!(hash.python_safe_encode(), "351f");
    }

    // #[test]
    // fn test_image_hash_from_string() {
    //     let hash = ImageHash::from_string("aa55aa55aa55aa55", 8, 8);

    //     assert_eq!(
    //         hash.matrix,
    //         vec![
    //             vec![true, false, true, false, true, false, true, false],
    //             vec![false, true, false, true, false, true, false, true],
    //             vec![true, false, true, false, true, false, true, false],
    //             vec![false, true, false, true, false, true, false, true],
    //             vec![true, false, true, false, true, false, true, false],
    //             vec![false, true, false, true, false, true, false, true],
    //             vec![true, false, true, false, true, false, true, false],
    //             vec![false, true, false, true, false, true, false, true],
    //         ]
    //     );
    // }
}
